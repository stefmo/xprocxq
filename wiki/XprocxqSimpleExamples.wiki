#summary using p:declare-step to define new reusable pipelines

These examples have been tested against xprocxq.

*note*: the links after each example will run your local eXist copy of /examples which you must upload to eXist.

<wiki:toc max_depth="1" />

== p:identity Hello World =

{{{

xquery version "1.0" encoding "UTF-8";

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=document{<test>Hello World</test>}

let $pipeline :=document{
                    <p:pipeline name="pipeline"
                                xmlns:p="http://www.w3.org/ns/xproc"
                                xmlns:c="http://www.w3.org/ns/xproc-step">
                        <p:identity/>
                    </p:pipeline>
                }

return
     xproc:run($pipeline,$stdin) 


}}}

[http://127.0.0.1:8080/exist/rest/examples/helloworld.xq helloworld.xq]

== p:xslt ==

{{{
xquery version "1.0" encoding "UTF-8";

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=document{<test/>}

let $pipeline :=document{
                    <p:pipeline name="pipeline"
                                xmlns:p="http://www.w3.org/ns/xproc"
                                xmlns:c="http://www.w3.org/ns/xproc-step">
                                <p:xslt>                                         
                                   <p:input port="stylesheet">
                                       <p:document href="{$local:XPROCXQ_EXAMPLES}/xslt/stylesheet.xsl"/>
                                   </p:input>
                                </p:xslt>

                    </p:pipeline>
                }

return
     xproc:run($pipeline,$stdin) 

}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/pxslt.xq pxslt.xq]



== p:xquery ==

{{{
xquery version "1.0" encoding "UTF-8";

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=document{<test/>}

let $pipeline :=document{
                    <p:pipeline name="pipeline"
                                xmlns:p="http://www.w3.org/ns/xproc"
                                xmlns:c="http://www.w3.org/ns/xproc-step">
                               <p:xquery>
                                   <p:input port="query">
                                       <p:inline>
                                           <c:query xmlns:c="http://www.w3.org/ns/xproc-step" xproc:escape="true">
                                               let $r := 'this pipeline successfully processed' return $r (: for now default context goes to xml database :)
                                           </c:query>
                                       </p:inline>
                                   </p:input>
                               </p:xquery>

                    </p:pipeline>
                }

return
     xproc:run($pipeline,$stdin) 


}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/pxslt.xq pxquery.xq]



== p:http-request ==

This pipeline makes an http GET request to http://tests.xproc.org/service/fixed-xml. You will need to ensure that expath.jar is installed and both EXPath and eXist http extension module are enabled.

{{{
xquery version "1.0" encoding "UTF-8";

(: example test for xprocxq:)

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace naming = "http://xproc.net/xproc/naming";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=()

let $pipeline :=document{<p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
                                     xmlns:c="http://www.w3.org/ns/xproc-step"
                           name="pipeline">

<p:http-request name="http-get">  (: http get test step :)
<p:input port="source">
  <p:inline>
    <c:request xmlns:c="http://www.w3.org/ns/xproc-step" 
               href="http://tests.xproc.org/service/fixed-xml" 
               method="get"/>
  </p:inline>
</p:input>
</p:http-request>

</p:pipeline>}

return
    xproc:run($pipeline,$stdin)
}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/phttp-request.xq phttp-request.xq]

This step returns a sequence of two items

{{{
<http:response xmlns:http="http://www.expath.org/mod/http-client" status="200">
    <http:header name="Date" value="Thu, 30 Apr 2009 17:25:08 GMT"/>
    <http:header name="Server" value="Apache/2.0.63 (Unix) PHP/4.4.7 mod_ssl/2.0.63 OpenSSL/0.9.7e mod_fastcgi/2.4.2 Phusion_Passenger/2.0.6 DAV/2 SVN/1.4.2"/>
    <http:header name="Content-Length" value="63"/>
    <http:header name="Content-Type" value="application/xml"/>
    <http:body content-type="application/xml"/>
</http:response>
<doc>
    <title>Sample document</title>
<p>Hello world!</p>

</doc>
}}}

Your browser will not be able to display this, so view source on the page to see the actual output.
== p:store ==

p:store can save document to eXist XML Database. To run this example you will have to allow write permissions for XQuery to generate storetest.xml to /db/examples/result collection, otherwise you will get an error.

{{{
xquery version "1.0" encoding "UTF-8";

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=document{<test/>}

let $pipeline :=document{
                    <p:pipeline name="pipeline"
                                xmlns:p="http://www.w3.org/ns/xproc"
                                xmlns:c="http://www.w3.org/ns/xproc-step">
                        <p:store href="{$local:XPROCXQ_EXAMPLES}/result/storetest.xml"/>
                    </p:pipeline>
                }

return
     xproc:run($pipeline,$stdin) 


}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/pstore.xq pstore.xq]

*note*: no support for file: and http: at this time

== p:choose ==

The p:choose step has a few [CurrentStatus Limitations] at this time

  * p:xpath-context does not work 
  * need to use special eXist convention for p:when paths ( `.//` for `//`)
  * to use output from a p:choose step need to explicitly define port binding

This example pipeline first compares 2 xml documents (both the same document) and returns either `<c:result>true</c:result>` or `<c:result>false</c:result>` if documents are equal or not. Based on that value a branch in the p:choose is executed.

{{{
xquery version "1.0" encoding "UTF-8";

(: example test for xprocxq:)

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace naming = "http://xproc.net/xproc/naming";
import module namespace u = "http://xproc.net/xproc/util";

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=doc(concat($local:XPROCXQ_EXAMPLES,'/xml/test.xml'))

let $pipeline :=document{<p:pipeline xmlns:p="http://www.w3.org/ns/xproc"
                                     xmlns:c="http://www.w3.org/ns/xproc-step"
                           name="pipeline">

<p:compare name="compare">                       (: compare test step :)
   <p:input port="alternate">
       <p:document href="{$local:XPROCXQ_EXAMPLES}/xml/test.xml"/> (: example of using p:document :)
   </p:input>
</p:compare>

<p:choose name="mychoosestep">
       <p:when test=".//c:result[.='false']">      (: note the eXist specific path convention with root :)
           <p:identity>
               <p:input port="source">
                   <p:inline>
                       <p>This pipeline failed.</p>
                   </p:inline>
               </p:input>
           </p:identity>
       </p:when>
       <p:when test=".//c:result[.='true']">  (: success :)
       <p:identity>
           <p:input port="source">
               <p:inline>
                   <p>This pipeline successfully processed.</p>
               </p:inline>
           </p:input>
       </p:identity>
       </p:when>
       <p:otherwise>
           <p:identity>
               <p:input port="source">
                   <p:inline>
                       <p>This pipeline failed.</p>
                   </p:inline>
               </p:input>
           </p:identity>
       </p:otherwise>
   </p:choose>

    <p:identity>        (: need to explicitly define p:step to get multi container step output :)
        <p:input port="source">
            <p:step port="result" step="mychoosestep"/>
        </p:input>
    </p:identity>


</p:pipeline>}

return
    xproc:run($pipeline,$stdin)
    
}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/pchoose.xq pchoose.xq]

== p:escape-markup / p:unescape-markup ==

{{{

}}}
[http://127.0.0.1:8080/exist/rest/examples/step_examples/pescapemarkup.xq pescapemarkup.xq]

== p:xsl-formatter ==

This example uses eXist own documentation (which should be in the /db/xqdocs collection) and convert to a simple pdf. To run this example you will have to allow write permissions for XQuery to generate storetest.xml to /db/examples/result collection, otherwise you will get an error.  

{{{
xquery version "1.0" encoding "UTF-8";

import module namespace const = "http://xproc.net/xproc/const";
import module namespace xproc = "http://xproc.net/xproc";
import module namespace naming = "http://xproc.net/xproc/naming";
import module namespace u = "http://xproc.net/xproc/util";

import module namespace xslfo = "http://exist-db.org/xquery/xslfo"; (: required for p:xsl-formatter :)

declare variable $local:XPROCXQ_EXAMPLES := "/db/examples";   (: CHANGE ME :)

let $stdin :=doc('/db/xqdocs/index.xml')//body             (: need eXist index page as example :)
  
let $pipeline :=document{<p:pipeline name="pipeline"
            xmlns:p="http://www.w3.org/ns/xproc">

<p:xslt>                                         
   <p:input port="stylesheet">
       <p:document href="{$local:XPROCXQ_EXAMPLES}/existdoc2pdf.xsl"/>
   </p:input>
</p:xslt>
<p:xsl-formatter href='{XPROCXQ_EXAMPLES}/result/existdocs.pdf'/>

</p:pipeline>}

return
    xproc:run($pipeline,$stdin)
        
        
}}}

[http://127.0.0.1:8080/exist/rest/examples/step_examples/pxslformatter.xq pxslformatter.xq]